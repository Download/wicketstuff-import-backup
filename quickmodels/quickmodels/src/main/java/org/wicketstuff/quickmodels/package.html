<!-- 
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>
  <body>
  This library is used for creating wicket models over objects persisted
  in a database.  It uses the Persistence Facade library for persistence,
  and implements Wicket models.  The goal is to make it trivial to write
  a database-enabled Wicket application.
  <p/>
  Database access is accomplished through the reading and writing of 
  POJOs (Plain Old Java Objects) - the Persistence Facade library handles
  the mechanics of this.
  <p/>
  This library supplies model classes and property classes which enable one
  to use standard Wicket mechanisms (such as reflection-based property lookup - 
  you name a Label with the name of the property on its model object that it
  should reflect, and the framework takes care of the rest.
  <p/>
  <h4>Why not just work with POJOs and property models - what's the point here?</h4>
  The value the Persistence Facade library, and this one, bring to the picture
  is management of object state.  In Wicket, the session is managed via
  serialization;  in the case of a clustered application, this data must be
  pushed over the wire.  So keeping session size small is important.
  <p/>
  By using the models provided here, POJOs can be instantiated and de-instantiated
  on demand.  So what is serialized into the session is usually just a <code>long</code>
  &mdash; a database ID.  When components are begin paying attention to a
  model, the object is instantiated on-demand.  When all models are detached,
  the object can be discarded.  This helps applications to scale, and keeps
  the memory footprint small.
  <h3>Usage</h3>
  Most usages of this library start from the <a href="Queries.html">Queries</a>
  class.  <code>Queries</code> is an enumeration of kinds of queries, with a
  method <code>builder</code> which can return a <a href="ModelBuilder.html">ModelBuilder</a>
  for that type of query.  A <code>ModelBuilder</code> is an object that can
  be populated with data about a database query, and then used to construct a
  Wicket model based on the result of that query.  No database access necessarily
  occurs until a component using the model actually needs a value from the
  POJO.  <code>ModelBuilder</code> has two methods, <code>single()</code> and
  <code>multi()</code>.  Use <code>single()</code> to get a 
  <a href="PojoModel.html">PojoModel</a>, for a single object - for example,
  looking up a unique object in the database by its ID.  Use <code>multi()</code>
  to get a <a href="PojoCollectionModel.html">PojoCollectionModel</a>, which is
  a wicket model of a collection of objects.  <code>PojoCollectionModel</code>
  is particularly useful in conjunction with Wicket <i>repeaters</i>, to 
  automatically display an ad-hoc number of pieces of data in a table or other
  HTML markup.
  <h4>Lookup up and displaying a collection of objects from a database</h4>
  <p/>
  So, for example, say that I want all known instances of my POJO class 
  <code>Comment</code>.  Comment has three properties:  <code>date</code>,
  <code>comment</code> and <code>name</code>.  We want to display all
  available comments in a table.
  The code to get a model over all available comments is simple:
  <pre>
final class CommentsPanel extends DbPanel<Comment> {
    CommentsPanel(String id) {
        super (id);
        PojoCollectionModel&lt;Comment&gt; model = 
                Queries.OF_TYPE.builder(Comment.class).multi(getDatabase());
        setModel (model);
  </pre>
  In this example we are extending <a href="DbPanel.html">DbPanel</a>, a
  convenience Wicket <code>Panel</code> subclass that offers a method for
  finding the database (use it in conjunction with 
  <a href="DbApplication.html">DbApplication</a>).
  <p/>
  Actually populating our panel with data is trivial.  The framework takes
  care of property-based lookup on the underlying POJO.  So all we need to 
  do is add the appropriate components:
  <pre>
        <font color="gray">//A data provider for repeaters which </font>
        <font color="gray">//works with a PojoCollectionModel</font>
        IDataProvider dataProvider = model.createDataProvider();
        DataView view = new DataView (&quot;repeater&quot;, dataProvider) {
            protected void populateItem(Item item) {
                <font color="gray">//All we need to do here is set </font>
                <font color="gray">//component names that match properties</font>
                <font color="gray">//on the class Comment - the rest is</font>
                <font color="gray">//taken care of</font>
                Label nameLbl = new Label (&quot;name&quot;);
                item.add (nameLbl);
                Label commentLbl = new Label (&quot;comment&quot;);
                item.add (commentLbl);
                Label dateLbl = new Label (&quot;date&quot;);
                item.add (dateLbl);
            }
        };
        add (view);
        if (model.isEmpty()) {
            <font color="gray">//Hide the whole panel if there's nothing to</font>
            <font color="gray">//show - this way we avoid an error since there will</font>
            <font color="gray">//be components declared but missing (the contents</font>
            <font color="gray">//of the DataView)</font>
            setVisible (false);
        }
    }
  </pre>
  The HTML for our panel is also trivial:
  <pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
      &lt;wicket:panel&gt;
          &lt;table border=&quot;1&quot;&gt;
              &lt;tr wicket:id=&quot;repeater&quot;&gt;
                  &lt;th wicket:id=&quot;name&quot;&gt;Name&lt;/th&gt;
                  &lt;td wicket:id=&quot;comment&quot;&gt;This is a comment&lt;/td&gt;
                  &lt;td wicket:id=&quot;date&quot;&gt;10/22/2002&lt;/td&gt;
              &lt;/tr&gt;
          &lt;/table&gt;
      &lt;/wicket:panel&gt;
  &lt;/body&gt;
&lt;/html&gt;
    </pre>
    <p/>
    We now have a panel that can be reused anywhere in our application, and
    which will display all available comments.
    <h4>Adding objects to the database</h4>
    Of course, we won't have any comments in our application if we don't
    have a way to add comments.  This is trivial as well:
    <pre>
final class AddCommentPanel extends DbPanel&lt;Comment&gt; {
    AddCommentPanel(String id) {
        super (id);
        <font color="gray">//Get a model that will instantiate a new instance of</font>
        <font color="gray">//Comment on demand</font>
        ModelBuilder&lt;Comment, ?&gt; builder =
                Queries.NEW_OBJECT.builder(Comment.class);
        setModel (builder.single(getDatabase()));
        CommentForm form = new CommentForm (&quot;commentform&quot;);
        add (form);
        <font color="gray">//Add a feedback panel to show validation errors</font>
        FeedbackPanel feedback = new FeedbackPanel (&quot;feedback&quot;);
        add (feedback);
    }
    
    private final class CommentForm extends Form {
        <font color="gray">//Notice we just give the components the same</font>
        <font color="gray">//name as the properties on the Comment class</font>
        private final TextField nameField = new TextField (&quot;name&quot;);
        private final TextArea commentArea = new TextArea (&quot;comment&quot;);
        CommentForm (String id) {
            super (id);
            add (nameField);
            add (commentArea);
        }

        protected void onSubmit() {
            <font color="gray">//Check for missing input</font>
            if (nameField.getModelObject() == null) {
                error (&quot;Enter your name&quot;);
                return;
            }
            if (commentArea.getModelObject() == null) {
                error (&quot;Enter a comment&quot;);
                return;
            }
            PojoModel&lt;Comment&gt; mdl = (PojoModel&lt;Comment&gt;) 
                    AddCommentPanel.this.getModel();
            mdl.modified();
            mdl.save();
            <font color="gray">//Force a new instance of the home page, so that the</font>
            <font color="gray">//visibility of the comments panel is updated</font>
            setResponsePage(Home.class);
        }
    }
}
    </pre>
    The HTML for the add comment form is similarly simple:
    <pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
      &lt;wicket:panel&gt;
          &lt;p/&gt;
          &lt;form wicket:id=&quot;commentform&quot;&gt;
              Your Name: &lt;input type=&quot;text&quot; wicket:id=&quot;name&quot;/&gt;
              &lt;br/&gt;
              Comment:&lt;br/&gt;
              &lt;textarea wicket:id=&quot;comment&quot; cols=&quot;30&quot; rows=&quot;5&quot;&gt;
                  Add a comment
              &lt;/textarea&gt;
              &lt;br/&gt;
              &lt;input type=&quot;submit&quot; value=&quot;Add Comment&quot;/&gt;
          &lt;/form&gt;
          &lt;span wicket:id=&quot;feedback&quot;&gt;Feedback here&lt;/span&gt;
      &lt;/wicket:panel&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
  <h4>Complex Queries</h4>
  The most powerful kind of query supported are <i>complex queries</i>.  These
  are created by assembling one or more QueryElements.  The primary class 
  used in creating such queries is <code>FieldQueryElement</code>, which
  represents one field on an object.  FieldQueryElements can descend through
  multiple objects, so it is possible to create one which refers to a field
  named &quot;foo.bar.baz&quot;, and the result will be a query of the baz
  field of the field called bar on the field called foo of all instances of
  whatever object is being queried.
  <p/>
  There are also some special value classes that can be passed to the constructor
  of a <code>FieldQueryElement</code>:
  <ul>
      <li>RangeValue - indicating a query should match any numeric field within
      an inclusive range of values</li>
      <li>StringContains, StringEndsWith and StringStartsWith objects - these
      are fairly self-explanatory</li>
  </ul>
  
  For example, say that
  we have a database of blogs, and we want to find Joe's most recent published
  blogs.  
 
  This would look like:
  <pre>
      <font color="gray">//And get a ModelBuilder to create our model</font>
      ModelBuilder builder = Queries.COMPLEX.builder (Blog.class);

      <font color="gray">//Query the field Blog.user.firstName, of type String.  </font>
      <font color="gray">//We want to match all instances of the name &quot;Joe&quot;  </font>
      FieldQueryElement blogsByJoe = new FieldQueryElement ("user.firstName",
        String.class, "Joe", false);
        
      <font color="gray">//We want to match all instances of Blog which were created in the last ten days</font>
      FieldQueryElement recent = new FieldQueryElement ("creationDate",
        Long.TYPE, new Range (System.currentTimeMillis() - TEN_DAYS, 
        System.currentTimeMillis(), false);
        
      <font color="gray">//Omit Blogs whose published field is false</font>
      FieldQueryElement published = new FieldQueryElement ("published",
        Boolean.TYPE, Boolean.TRUE, false);
        
      <font color="gray">//Logically AND our query elements</font>
      QueryElement theQuery = blogsByJoe.and(recent).and(published);

      <font color="gray">//Pass it the details of our query</font>
      builder.setObject (theQuery);
      <font color="gray">//And have it make a model representing the result of the query</font>
      PojoCollectionModel&lt;Blog&gt; model = builder.multi();
      setModel (model);
  </pre>

    <h4>Other Kinds of Queries</h4>
    Other kinds of queries are available.  For example, there are UID (unique ID)
    and UUID (string-based universal unique ID - suitable for permalinks) based
    queries for looking up a specific object.  You can query for objects of a
    given type with a field of a particular value.  Or you can create a prototype
    POJO with some fields set and some null, and match all objects whose non-null
    field values match the ones in the prototype POJO.  Or if you already have
    instantiated some objects, you can use <code>Queries.EXISTING_OBJECTS</code>
    to create a model over those objects.  Or if none of these is satisfactory,
    you can write a custom query that interacts with the database container
    directly (though this does mean your application will be tied to the 
    implementation type of the container, so switching databases will require
    some code changes).
    
    <h4>Running Database-specific Queries</h4>
    It is also possible to interact directly with the native database container.
    For example, db4o supports a concept of &quot;native queries&quot; which
    do not have an analogue in this API.  To do something like this, simply
    implement the <code>DbJob</code> interface to return a list of whatever
    type of object you want, and pass that to 
    <code>Db.getFacadeFactory()</code>.  Note that this, of course, ties your
    application more tightly to the native database container type, but it can
    be useful in a pinch.
    
  </body>
</html>
